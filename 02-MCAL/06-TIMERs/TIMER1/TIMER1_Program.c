/****************************************************************/
/* 		Author   	 : Mark Ehab                    */
/* 		Date     	 : Feb 10, 2022               	*/
/*              SWC              : TIMER1			*/
/*              Description	 : TIMER1 Program               */
/* 	        Version          : V1.0                         */
/****************************************************************/

#include "../../../LIB/BIT_MATH.h"
#include "../../../LIB/STD_TYPES.h"
#include "../../../LIB/STD_ERRORS.h"
#include "../../../LIB/SERVICE_FUNCTIONS.h"

#include "TIMER1_Interface.h"
#include "TIMER1_Private.h"
#include "TIMER1_Config.h"

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/*                            GLOBAL VARIABLES DEFINITIONS	                     */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/

static f32 Global_f32Timer1OverflowTime = ((f32)TIMER1_PRESCALER/(f32)TIMER1_MCU_CLK_FREQ) * (f32)TIMER1_OVERFLOW_TICKS;	/* Global Variable to Hold Timer1 Overflow Time */
static void (*TIMER1_pvOverflowCallbackFunc)(void);										/* Pointer to Function to Hold Address of Overflow Function to Be Called Once Timer1 Overflow ISR is Triggered */
static void (*TIMER1_pvComapareMatchACallbackFunc)(void);									/* Pointer to Function to Hold Address of Output Compare Match Channel A Function to Be Called Once Timer1 Compare Match ISR for Channel A is Triggered  */
static void (*TIMER1_pvComapareMatchBCallbackFunc)(void);									/* Pointer to Function to Hold Address of Output Compare Match Channel B Function to Be Called Once Timer1 Compare Match ISR for Channel B is Triggered  */
static void (*TIMER1_pvCaptureEventCallbackFunc)(void);										/* Pointer to Function to Hold Address of Capture Event Function to Be Called Once Timer1 Capture Event ISR is Triggered */

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/*                           	  PRIVATE FUNCTIONS		                     */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/

/**********************************************************************************/
/* Description     : Calculate Timer1 preload value     			  */
/* Input Arguments : f32 Copy_f32Delay_s , u32 Copy_u32OverflowNum	          */
/* Return          : u16						          */
/**********************************************************************************/
static u16 TIMER1_u16CalculateTimer1PreloadVal(f32 Copy_f32Delay_s , u32 Copy_u32OverflowNum)
{
	/* Define Some Local Variables */
	u16 Local_u16PreloadValue; 	/* Variable to hold preload value to be put in TCNT1 register before Timer1 starts */

	/* Check if passed delay is greater, less or equal to overflow time  */
	if(Copy_f32Delay_s > Global_f32Timer1OverflowTime)
	{
		Local_u16PreloadValue = TIMER1_OVERFLOW_TICKS * ((f32)Copy_u32OverflowNum-(Copy_f32Delay_s/Global_f32Timer1OverflowTime));
	}
	else if(Copy_f32Delay_s < Global_f32Timer1OverflowTime)
	{
		Local_u16PreloadValue = TIMER1_OVERFLOW_TICKS * (1.0f-(Copy_f32Delay_s/Global_f32Timer1OverflowTime));
	}
	else
	{
		Local_u16PreloadValue = 0;
	}

	return Local_u16PreloadValue;
}
/**********************************************************************************/
/* Description     : Set duty cycle value of PWM to be generated by Timer1 from   */
/*		     channel A							  */
/* Input Arguments : u8 Copy_u8DutyCycleChA			 	          */
/* Return          : u8						                  */
/**********************************************************************************/
static u8 TIMER1_u8SetDutyCycleChA(u8 Copy_u8DutyCycleChA)
{
	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;     		/* A variable to hold function error status */

	if(Copy_u8DutyCycleChA <= 100)
	{
		u16 Local_u16CompareMatchAValue;		/* A variable to hold compare match of channel A value to be calculated */

		#if   TIMER1_MODE == PHASE_CORRECT_PWM_EIGHT_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchAValue = 0x00FF * ((f32)Copy_u8DutyCycleChA * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_u16CompareMatchAValue = 0x00FF - (0x00FF * ((f32)Copy_u8DutyCycleChA * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_NINE_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchAValue = 0x01FF * ((f32)Copy_u8DutyCycleChA * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_u16CompareMatchAValue = 0x01FF - (0x01FF * ((f32)Copy_u8DutyCycleChA * 0.01f));

			#endif

                #elif TIMER1_MODE == PHASE_CORRECT_PWM_TEN_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchAValue = 0x03FF * ((f32)Copy_u8DutyCycleChA * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_u16CompareMatchAValue = 0x03FF - (0x03FF * ((f32)Copy_u8DutyCycleChA * 0.01f));

			#endif


                #elif TIMER1_MODE == FAST_PWM_EIGHT_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchAValue = 0x00FF * ((f32)Copy_u8DutyCycleChA * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_u16CompareMatchAValue = 0x00FF - (0x00FF * ((f32)Copy_u8DutyCycleChA * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_NINE_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchAValue = 0x01FF * ((f32)Copy_u8DutyCycleChA * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_u16CompareMatchAValue = 0x01FF - (0x01FF * ((f32)Copy_u8DutyCycleChA * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_TEN_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchAValue = 0x03FF * ((f32)Copy_u8DutyCycleChA * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_u16CompareMatchAValue = 0x03FF - (0x03FF * ((f32)Copy_u8DutyCycleChA * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_ICR1_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchAValue = ICR1 * ((f32)Copy_u8DutyCycleChA * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_u16CompareMatchAValue = ICR1 - (ICR1 * ((f32)Copy_u8DutyCycleChA * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_ICR1_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchAValue = ICR1 * ((f32)Copy_u8DutyCycleChA * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE

				Local_u16CompareMatchAValue = ICR1 - (ICR1 * ((f32)Copy_u8DutyCycleChA * 0.01f));

			#endif
		#endif


		/* Set Calculated Compare Match Value of Channel A */
		TIMER1_vidSetCompareMatchAValue(Local_u16CompareMatchAValue);

	}
	else
	{
		/* Function is not working as expected */
		Local_u8ErrorStatus = RT_NOK;
	}

	return Local_u8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Set duty cycle value of PWM to be generated by Timer1 from   */
/*		     channel B							  */
/* Input Arguments : u8 Copy_u8DutyCycleChB			 	          */
/* Return          : u8						                  */
/**********************************************************************************/
static u8 TIMER1_u8SetDutyCycleChB(u8 Copy_u8DutyCycleChB)
{
	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;     		/* A variable to hold function error status */

	if(Copy_u8DutyCycleChB <= 100)
	{
		u16 Local_u16CompareMatchBValue;		/* A variable to hold compare match of channel B value to be calculated */

		#if   TIMER1_MODE == PHASE_CORRECT_PWM_EIGHT_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = 0x00FF * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = 0x00FF - (0x00FF * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_NINE_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = 0x01FF * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = 0x01FF - (0x01FF * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == PHASE_CORRECT_PWM_TEN_BIT_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = 0x03FF * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = 0x03FF - (0x03FF * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif


                #elif TIMER1_MODE == FAST_PWM_EIGHT_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = 0x00FF * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = 0x00FF - (0x00FF * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_NINE_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = 0x01FF * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = 0x01FF - (0x01FF * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_TEN_BIT_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = 0x03FF * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = 0x03FF - (0x03FF * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_ICR1_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = ICR1 * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = ICR1 - (ICR1 * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_ICR1_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = ICR1 * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = ICR1 - (ICR1 * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif

		#elif TIMER1_MODE == PHASE_CORRECT_PWM_OCR1A_MODE

			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = OCR1A * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = OCR1A - (OCR1A * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif

                #elif TIMER1_MODE == FAST_PWM_OCR1A_MODE

			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE

				Local_u16CompareMatchBValue = OCR1A * ((f32)Copy_u8DutyCycleChB * 0.01f);

			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE

				Local_u16CompareMatchBValue = OCR1A - (OCR1A * ((f32)Copy_u8DutyCycleChB * 0.01f));

			#endif
		#endif


		/* Set Calculated Compare Match Value of Channel B */
		TIMER1_vidSetCompareMatchBValue(Local_u16CompareMatchBValue);

	}
	else
	{
		/* Function is not working as expected */
		Local_u8ErrorStatus = RT_NOK;
	}

	return Local_u8ErrorStatus;
}

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/*                           	  PUBLIC FUNCTIONS		                     */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/

/**********************************************************************************/
/* Description     : Initialize Timer1 based on selected configurations from      */
/* 		     config file						  */
/* Input Arguments : void						          */
/* Return          : void						          */
/**********************************************************************************/
void TIMER1_vidInit(void)
{
	/******************************************Set TIMER1 Operating Mode*****************************************/
	/* Clear waveform generation bits */
	CLR_BIT(TCCR1A,TCCR1A_WGM10);
	CLR_BIT(TCCR1A,TCCR1A_WGM11);
	CLR_BIT(TCCR1B,TCCR1B_WGM12);
	CLR_BIT(TCCR1B,TCCR1B_WGM13);

	/* Check selected Timer1 mode from config file */
	#if   TIMER1_MODE == OVERFLOW_MODE
		/* Set Timer1 to work in overflow mode */
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
		CLR_BIT(TCCR1A,TCCR1A_WGM11);
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_EIGHT_BIT_MODE
		/* Set Timer1 to work in phase-correct PWM mode with 8-bit resolution */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		CLR_BIT(TCCR1A,TCCR1A_WGM11);
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_NINE_BIT_MODE
		/* Set Timer1 to work in phase-correct PWM mode with 9-bit resolution */
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_TEN_BIT_MODE
		/* Set Timer1 to work in phase-correct PWM mode with 10-bit resolution */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == CTC_OCR1A_MODE
		/* Set Timer1 to work in CTC mode with OCR1A value as top */
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
		CLR_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_EIGHT_BIT_MODE
		/* Set Timer1 to work in FastPWM mode with 8-bit resolution */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		CLR_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_NINE_BIT_MODE
		/* Set Timer1 to work in FastPWM mode with 9-bit resolution */
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_TEN_BIT_MODE
		/* Set Timer1 to work in FastPWM mode with 10-bit resolution */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		CLR_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_FREQUENCY_CORRECT_PWM_ICR1_MODE
		/* Set Timer1 to work in PWM Phase and Frequency Correct mode with ICR1 value as top */
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
		CLR_BIT(TCCR1A,TCCR1A_WGM11);
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_FREQUENCY_CORRECT_PWM_OCR1A_MODE
		/* Set Timer1 to work in PWM Phase and Frequency Correct mode with OCR1A value as top */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		CLR_BIT(TCCR1A,TCCR1A_WGM11);
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_ICR1_MODE
		/* Set Timer1 to work in phase-correct PWM with ICR1 value as top */
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_OCR1A_MODE
		/* Set Timer1 to work in phase-correct PWM with OCR1A value as top */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		CLR_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == CTC_ICR1_MODE
		/* Set Timer1 to work in CTC mode with ICR1 value as top */
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
		CLR_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_ICR1_MODE
		/* Set Timer1 to work in FastPWM mode with ICR1 value as top */
		CLR_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#elif TIMER1_MODE == FAST_PWM_OCR1A_MODE
		/* Set Timer1 to work in FastPWM mode with OCR1A value as top */
		SET_BIT(TCCR1A,TCCR1A_WGM10);
		SET_BIT(TCCR1A,TCCR1A_WGM11);
		SET_BIT(TCCR1B,TCCR1B_WGM12);
		SET_BIT(TCCR1B,TCCR1B_WGM13);
	#else
		#error "Wrong Timer1 Mode Configuration !"
	#endif


	/******************************************Set Timer1 Output Compare Match Pin Mode for both channels A & B*****************************************/
	/* Clear Timer1 output compare match pin mode bits for channel A */
	TCCR1A &= TIMER1_OUTPUT_COMPARE_PIN_CHA_MODE_MASK;

	/* Clear Timer1 output compare match pin mode bits for channel B */
	TCCR1A &= TIMER1_OUTPUT_COMPARE_PIN_CHB_MODE_MASK;

	/* Check selected Timer1 mode from config file */
	#if   TIMER1_MODE == OVERFLOW_MODE || TIMER1_MODE == CTC_OCR1A_MODE || TIMER1_MODE == CTC_ICR1_MODE
		/* Check selected Timer1 output compare match channel */
		#if   TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELA
			#if   TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == TOGGLE
				/* Toggle Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_TOGGLE;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == CLEAR
				/* Clear Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_CLEAR;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == SET
				/* Set Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_SET;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Non PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELB
			#if   TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == TOGGLE
				/* Toggle Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_TOGGLE;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == CLEAR
				/* Clear Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_CLEAR;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == SET
				/* Set Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_SET;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Non PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == BOTH_CHANNELS
			/* Channel A */
			#if   TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == TOGGLE
				/* Toggle Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_TOGGLE;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == CLEAR
				/* Clear Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_CLEAR;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == SET
				/* Set Timer1 OC1A Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHA_SET;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Non PWM) Configuration !"
			#endif
			/* Channel B */
			#if   TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == TOGGLE
				/* Toggle Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_TOGGLE;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == CLEAR
				/* Clear Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_CLEAR;
			#elif TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == SET
				/* Set Timer1 OC1B Pin */
				TCCR1A |= TIMER1_NON_PWM_OUTPUT_COMPARE_PIN_CHB_SET;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Non PWM) Configuration !"
			#endif
		#else
			#error "Wrong Timer1 Output Compare Match Channel Selection !"
		#endif
	#elif TIMER1_MODE == FAST_PWM_EIGHT_BIT_MODE || TIMER1_MODE == FAST_PWM_NINE_BIT_MODE || TIMER1_MODE == FAST_PWM_TEN_BIT_MODE || TIMER1_MODE == FAST_PWM_ICR1_MODE || TIMER1_MODE == FAST_PWM_OCR1A_MODE
		/* Check selected Timer1 output compare match channel */
		#if   TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELA
			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_NON_INVERTED_MODE;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Fast PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELB
			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_NON_INVERTED_MODE;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Fast PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == BOTH_CHANNELS
		       /* Channel A */
			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_NON_INVERTED_MODE;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHA_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Fast PWM) Configuration !"
			#endif
		       /* Channel B */
			#if   TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_NON_INVERTED_MODE;
			#elif TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_FAST_PWM_OUTPUT_COMPARE_PIN_CHB_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Fast PWM) Configuration !"
			#endif
		#else
			#error "Wrong Timer1 Output Compare Match Channel Selection !"
		#endif
	#elif TIMER1_MODE == PHASE_CORRECT_PWM_EIGHT_BIT_MODE || TIMER1_MODE == PHASE_CORRECT_PWM_NINE_BIT_MODE || TIMER1_MODE == PHASE_CORRECT_PWM_TEN_BIT_MODE || TIMER1_MODE == PHASE_FREQUENCY_CORRECT_PWM_ICR1_MODE || TIMER1_MODE == PHASE_FREQUENCY_CORRECT_PWM_OCR1A_MODE || TIMER1_MODE == PHASE_CORRECT_PWM_ICR1_MODE || TIMER1_MODE == PHASE_CORRECT_PWM_OCR1A_MODE
		/* Check selected Timer1 output compare match channel */
		#if   TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELA
			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_NON_INVERTED_MODE;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Phase-Correct PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == CHANNELB
			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_NON_INVERTED_MODE;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Phase-Correct PWM) Configuration !"
			#endif
		#elif TIMER1_OUTPUT_COMPARE_MATCH_CHANNEL == BOTH_CHANNELS
			/* Channel A */
			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1A Pin */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_DISCONNECTED;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_NON_INVERTED_MODE;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_MODE == INVERTED_MODE
				/* Set Timer1 OC1A Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHA_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel A (Phase-Correct PWM) Configuration !"
			#endif
			/* Channel B */
			#if   TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == DISCONNECTED
				/* Disconnect Timer1 OC1B Pin */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_DISCONNECTED;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == NON_INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Non-Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_NON_INVERTED_MODE;
			#elif TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_MODE == INVERTED_MODE
				/* Set Timer1 OC1B Pin to Operate in Inverted Mode */
				TCCR1A |= TIMER1_PHASE_CORRECT_PWM_OUTPUT_COMPARE_PIN_CHB_INVERTED_MODE;
			#else
				#error "Wrong Timer1 Output Compare Match Pin for Channel B (Phase-Correct PWM) Configuration !"
			#endif
		#else
			#error "Wrong Timer1 Output Compare Match Channel Selection !"
		#endif
	#else
		#error "Wrong Timer1 Mode Configuration !"
	#endif

        /******************************************Enable/Disable Timer1 Interrupts*****************************************/
	/* Check if Timer1 overflow interrupt is enabled or not from config file */
	#if   TIMER1_OVERFLOW_INTERRUPT_ENABLE == ENABLE
				/* Enable Timer1 Overflow Interrupt */
				SET_BIT(TIMSK,TIMSK_TOIE1);
	#elif TIMER1_OVERFLOW_INTERRUPT_ENABLE == DISABLE
				/* Disable Timer1 Overflow Interrupt */
				CLR_BIT(TIMSK,TIMSK_TOIE1);
	#else
		#error "Wrong Timer1 Overflow Interrupt Enable Signal Configuration !"
	#endif

	/* Check if Timer1 compare match for channel A interrupt is enabled or not from config file */
	#if   TIMER1_COMPARE_MATCH_A_INTERRUPT_ENABLE == ENABLE
				/* Enable Timer1 compare match for channel A interrupt */
				SET_BIT(TIMSK,TIMSK_OCIE1A);
	#elif TIMER1_COMPARE_MATCH_A_INTERRUPT_ENABLE == DISABLE
				/* Disable Timer1 compare match for channel A interrupt */
				CLR_BIT(TIMSK,TIMSK_OCIE1A);
	#else
		#error "Wrong Timer1 Compare Match for Channel A Interrupt Enable Signal Configuration !"
	#endif

	/* Check if Timer1 compare match for channel B interrupt is enabled or not from config file */
	#if   TIMER1_COMPARE_MATCH_B_INTERRUPT_ENABLE == ENABLE
				/* Enable Timer1 compare match for channel B interrupt */
				SET_BIT(TIMSK,TIMSK_OCIE1B);
	#elif TIMER1_COMPARE_MATCH_B_INTERRUPT_ENABLE == DISABLE
				/* Disable Timer1 compare match for channel B interrupt */
				CLR_BIT(TIMSK,TIMSK_OCIE1B);
	#else
		#error "Wrong Timer1 Compare Match for Channel B Interrupt Enable Signal Configuration !"
	#endif

	/* Check if Timer1 capture event interrupt is enabled or not from config file */
	#if   TIMER1_CAPTURE_EVENT_INTERRUPT_ENABLE == ENABLE
				/* Enable Timer1 capture event interrupt */
				SET_BIT(TIMSK,TIMSK_TICIE1);
	#elif TIMER1_CAPTURE_EVENT_INTERRUPT_ENABLE == DISABLE
				/* Disable Timer1 capture event interrupt */
				CLR_BIT(TIMSK,TIMSK_TICIE1);
	#else
		#error
	#endif
}
/**********************************************************************************/
/* Description     : Start Timer1 by setting Timer1 prescaler selected from       */
/* 		     config file					          */
/* Input Arguments : void						          */
/* Return          : void						          */
/**********************************************************************************/
void TIMER1_vidStart(void)
{
	/* Clear Timer1 Clock Selection Bits */
	TCCR1B &= TIMER1_CLK_MASK;

	/* Check Selected Prescaler Value from Config File to Start Timer1 */
	#if   TIMER1_PRESCALER == CLK_DIV_BY_NO_PRESCALER
		/* Set Timer1 clock to be the same as system clock without division by any prescalers */
		TCCR1B |= TIMER1_CLK_DIV_BY_NO_PRESCALER;
	#elif TIMER1_PRESCALER == CLK_DIV_BY_8
		/* Set Timer1 clock to be system clock but divided by 8 prescaler */
		TCCR1B |= TIMER1_CLK_DIV_BY_8;
	#elif TIMER1_PRESCALER == CLK_DIV_BY_64
		/* Set Timer1 clock to be system clock but divided by 64 prescaler */
		TCCR1B |= TIMER1_CLK_DIV_BY_64;
	#elif TIMER1_PRESCALER == CLK_DIV_BY_256
		/* Set Timer1 clock to be system clock but divided by 256 prescaler */
		TCCR1B |= TIMER1_CLK_DIV_BY_256;
	#elif TIMER1_PRESCALER == CLK_DIV_BY_1024
		/* Set Timer1 clock to be system clock but divided by 1024 prescaler */
		TCCR1B |= TIMER1_CLK_DIV_BY_1024;
	#elif TIMER1_PRESCALER == EXT_CLK_FALLING_EDGE
		/* Set Timer1 to work on external clock source on T1 pin (clock on falling edge) */
		TCCR1B |= TIMER1_EXT_CLK_FALLING_EDGE;
	#elif TIMER1_PRESCALER == EXT_CLK_RISING_EDGE
		/* Set Timer1 to work on external clock source on T1 pin (clock on rising edge) */
		TCCR1B |= TIMER1_EXT_CLK_RISING_EDGE;
	#else
			#error
#endif
}
/**********************************************************************************/
/* Description     : Stop Timer1  					          */
/* Input Arguments : void						          */
/* Return          : void						          */
/**********************************************************************************/
void TIMER1_vidStop(void)
{
	/* Clear Timer1 Clock Selection Bits (Stop Timer1) */
	TCCR1B &= TIMER1_CLK_MASK;
}
/**********************************************************************************/
/* Description     : Set preload value					          */
/* Input Arguments : u16 Copy_u16PreloadValue                                     */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidSetPreloadValue(u16 Copy_u16PreloadValue)
{
	/* Set Timer1 Preload Value in TCNT1 Register  */
	TCNT1 = Copy_u16PreloadValue;
}
/**********************************************************************************/
/* Description     : Set compare match A value				          */
/* Input Arguments : u16 Copy_u16CompareMatchAValue                               */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidSetCompareMatchAValue(u16 Copy_u16CompareMatchAValue)
{
	/* Set Timer1 Compare Match Value for Channel A in OCR1A Register */
	OCR1A = Copy_u16CompareMatchAValue;
}
/**********************************************************************************/
/* Description     : Set compare match B value				          */
/* Input Arguments : u16 Copy_u16CompareMatchBValue                               */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidSetCompareMatchBValue(u16 Copy_u16CompareMatchBValue)
{
	/* Set Timer1 Compare Match Value for Channel B in OCR1B Register */
	OCR1B = Copy_u16CompareMatchBValue;
}
/**********************************************************************************/
/* Description     : Set input capture value				          */
/* Input Arguments : u16 Copy_u16InputCaptureValue                                */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidSetInputCaptureValue(u16 Copy_u16InputCaptureValue)
{
	/* Set Timer1 Input Capture Value in ICR1 Register */
	ICR1 = Copy_u16InputCaptureValue;
}
/**********************************************************************************/
/* Description     : Read Timer/Counter1 Value				          */
/* Input Arguments : void                                                         */
/* Return          : u16                                		          */
/**********************************************************************************/
u16 TIMER1_u16ReadTimerValue(void)
{
	/* Return Timer/Counter1 Value */
	return TCNT1;
}
/**********************************************************************************/
/* Description     : Enable Timer1 Overflow Interrupt			          */
/* Input Arguments : void                                                         */
/* Return          : void                                		          */
/**********************************************************************************/
void TIMER1_vidEnableOverflowInterrupt(void)
{
	/* Enable Timer1 Overflow Interrupt */
	SET_BIT(TIMSK,TIMSK_TOIE1);
}
/**********************************************************************************/
/* Description     : Disable Timer1 Overflow Interrupt			          */
/* Input Arguments : void                        			          */
/* Return          : void                               	                  */
/**********************************************************************************/
void TIMER1_vidDisableOverflowInterrupt(void)
{
	/* Disable Timer1 Overflow Interrupt */
	CLR_BIT(TIMSK,TIMSK_TOIE1);
}
/**********************************************************************************/
/* Description     : Enable Timer1 Compare Match A Interrupt		          */
/* Input Arguments : void                            		    	          */
/* Return          : void                       		                  */
/**********************************************************************************/
void TIMER1_vidEnableCompareMatchAInterrupt(void)
{
	/* Enable Timer1 compare match for channel A interrupt */
	SET_BIT(TIMSK,TIMSK_OCIE1A);
}
/**********************************************************************************/
/* Description     : Disable Timer1 Compare Match A Interrupt		          */
/* Input Arguments : void                       				  */
/* Return          : void                    			                  */
/**********************************************************************************/
void TIMER1_vidDisableCompareMatchAInterrupt(void)
{
	/* Disable Timer1 compare match for channel A interrupt */
	CLR_BIT(TIMSK,TIMSK_OCIE1A);
}
/**********************************************************************************/
/* Description     : Enable Timer1 Compare Match B Interrupt		          */
/* Input Arguments : void                            		    	          */
/* Return          : void                       		                  */
/**********************************************************************************/
void TIMER1_vidEnableCompareMatchBInterrupt(void)
{
	/* Enable Timer1 compare match for channel B interrupt */
	SET_BIT(TIMSK,TIMSK_OCIE1B);
}
/**********************************************************************************/
/* Description     : Disable Timer1 Compare Match B Interrupt		          */
/* Input Arguments : void                       				  */
/* Return          : void                    			                  */
/**********************************************************************************/
void TIMER1_vidDisableCompareMatchBInterrupt(void)
{
	/* Disable Timer1 compare match for channel B interrupt */
	CLR_BIT(TIMSK,TIMSK_OCIE1B);
}
/**********************************************************************************/
/* Description     : Enable Timer1 Capture Event Interrupt		          */
/* Input Arguments : void                            		    	          */
/* Return          : void                       		                  */
/**********************************************************************************/
void TIMER1_vidEnableCaptureEventInterrupt(void)
{
	/* Enable Timer1 capture event interrupt */
	SET_BIT(TIMSK,TIMSK_TICIE1);
}
/**********************************************************************************/
/* Description     : Disable Timer1 Capture Event Interrupt		          */
/* Input Arguments : void                       				  */
/* Return          : void                    			                  */
/**********************************************************************************/
void TIMER1_vidDisableCaptureEventInterrupt(void)
{
	/* Disable Timer1 capture event interrupt */
	CLR_BIT(TIMSK,TIMSK_TICIE1);
}
/**********************************************************************************/
/* Description     : Register application callback function that will be called   */
/*		     immediately once Timer1 overflow ISR is triggered		  */
/* Input Arguments : void(*Copy_pvTIMER1OverflowFunc)(void)		          */
/* Return          : u8						                  */
/**********************************************************************************/
u8 TIMER1_u8SetOverflowCallback(void(*Copy_pvTIMER1OverflowFunc)(void))
{
	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pvTIMER1OverflowFunc == NULL)
	{
		/* Passed Pointer is NULL Pointer */
		Local_u8ErrorStatus = NULL_POINTER;
	}
	else
	{
		/* Register Timer1 Overflow Callback Function */
		TIMER1_pvCaptureEventCallbackFunc = Copy_pvTIMER1OverflowFunc;
	}
	return Local_u8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Register application callback function that will be called   */
/*		     immediately once Timer1 compare match A ISR is triggered	  */
/* Input Arguments : void(*Copy_pvTIMER1CompareMatchAFunc)(void)		  */
/* Return          : u8						                  */
/**********************************************************************************/
u8 TIMER1_u8SetCompareMatchACallback(void(*Copy_pvTIMER1CompareMatchAFunc)(void))
{
	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pvTIMER1CompareMatchAFunc == NULL)
	{
		/* Passed Pointer is NULL Pointer */
		Local_u8ErrorStatus = NULL_POINTER;
	}
	else
	{
		/* Register Timer1 Compare Match For Channel A Function */
		TIMER1_pvComapareMatchACallbackFunc = Copy_pvTIMER1CompareMatchAFunc;
	}
	return Local_u8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Register application callback function that will be called   */
/*		     immediately once Timer1 compare match B ISR is triggered	  */
/* Input Arguments : void(*Copy_pvTIMER1CompareMatchBFunc)(void)		  */
/* Return          : u8						                  */
/**********************************************************************************/
u8 TIMER1_u8SetCompareMatchBCallback(void(*Copy_pvTIMER1CompareMatchBFunc)(void))
{
	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pvTIMER1CompareMatchBFunc == NULL)
	{
		/* Passed Pointer is NULL Pointer */
		Local_u8ErrorStatus = NULL_POINTER;
	}
	else
	{
		/* Register Timer1 Compare Match For Channel A Function */
		TIMER1_pvComapareMatchBCallbackFunc = Copy_pvTIMER1CompareMatchBFunc;
	}
	return Local_u8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Register application callback function that will be called   */
/*		     immediately once Timer1 capture event ISR is triggered	  */
/* Input Arguments : void(*Copy_pvTIMER1CaptureEventFunc)(void)		 	  */
/* Return          : u8						                  */
/**********************************************************************************/
u8 TIMER1_u8SetCaptureEventCallback(void(*Copy_pvTIMER1CaptureEventFunc)(void))
{
	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pvTIMER1CaptureEventFunc == NULL)
	{
		/* Passed Pointer is NULL Pointer */
		Local_u8ErrorStatus = NULL_POINTER;
	}
	else
	{
		/* Register Timer1 Capture Event Function */
		TIMER1_pvCaptureEventCallbackFunc = Copy_pvTIMER1CaptureEventFunc;
	}
	return Local_u8ErrorStatus;
}
/**********************************************************************************/
/* Description     : A function used to delay the processor for some time in      */
/*		     milli-second based on passed value of time in milli-second   */
/* Input Arguments : u32 Copy_u32DelayTime_ms				          */
/* Return          : u8                                                	          */
/**********************************************************************************/
u8 TIMER1_u8SetBusyWait_ms(u32 Copy_u32DelayTime_ms)
{
	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;	   /* A variable to hold function error status */

	/* Check if passed value in milli-second is out of range or not */
	if(Copy_u32DelayTime_ms < 4294967296)
	{
		f32 Local_f32DelayTime_s;               /* A variable to hold passed delay time in seconds */

		u32 Local_u32OverflowNum;		/* A variable to hold number of overflows required for Timer1 to achieve passed delay */

		u32 Local_u32OverflowCounter = 0;	/* A variable to count the number of overflows */

		u16 Local_u16PreloadValue ;		/* A variable to hold preload value to be calculated */

		/* Convert passed delay from milli-second to second */
		Local_f32DelayTime_s = (f32)Copy_u32DelayTime_ms * 0.001f;

		/* Get number of overflows required for Timer1 to reach passed delay */
		Local_u32OverflowNum = SERV_u32CeilDev(Local_f32DelayTime_s,Global_f32Timer1OverflowTime);

		/* Get Preload Value */
		Local_u16PreloadValue = TIMER1_u16CalculateTimer1PreloadVal(Local_f32DelayTime_s,Local_u32OverflowNum);

		/* Set Preload Value */
		TIMER1_vidSetPreloadValue(Local_u16PreloadValue);

		/* Start Timer 1 */
		TIMER1_vidStart();

		/* Wait until the delay is finished */
		while(Local_u32OverflowCounter < Local_u32OverflowNum)
		{
			/* Wait until TOV1 Flag is set by hardware */
			while(GET_BIT(TIFR,TIFR_TOV1) != 1);

			/* Clear TOV1 Flag by writing 1 to its bit in TIFR Register */
			SET_BIT(TIFR,TIFR_TOV1);

			/* Increment Overflow Counter */
			Local_u32OverflowCounter++;
		}

		/* Stop Timer1 */
		TIMER1_vidStop();
	}
	else
	{
		/* Function is not working as expected */
		Local_u8ErrorStatus = RT_NOK;
	}
	return Local_u8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Start to generate PWM from Timer1 Output Compare Match 	  */
/*		     Channel A						          */
/* Input Arguments : u8 Copy_u8DutyCyclePercentage				  */
/* Return          : void						          */
/**********************************************************************************/
u8 TIMER1_u8StartPWMChannelA(u8 Copy_u8DutyCyclePercentage)
{

	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed value is out of range or not */
	if(Copy_u8DutyCyclePercentage <= 100)
	{
		/* Set Duty Cycle Percentage */
		TIMER1_u8SetDutyCycleChA(Copy_u8DutyCyclePercentage);

		/* Start Timer1 */
		TIMER1_vidStart();
	}
	else
	{
		/* Function is not working as expected */
		Local_u8ErrorStatus = RT_NOK;
	}
	return Local_u8ErrorStatus;
}
/**********************************************************************************/
/* Description     : Start to generate PWM from Timer1 Output Compare Match 	  */
/*		     Channel B						          */
/* Input Arguments : u8 Copy_u8DutyCyclePercentage				  */
/* Return          : void						          */
/**********************************************************************************/
u8 TIMER1_u8StartPWMChannelB(u8 Copy_u8DutyCyclePercentage)
{
	/* Define Some Local Variables */
	u8 Local_u8ErrorStatus = RT_OK;   /* A variable to hold function error status */

	/* Check if passed value is out of range or not */
	if(Copy_u8DutyCyclePercentage <= 100)
	{
		/* Set Duty Cycle Percentage */
		TIMER1_u8SetDutyCycleChB(Copy_u8DutyCyclePercentage);

		/* Start Timer1 */
		TIMER1_vidStart();
	}
	else
	{
		/* Function is not working as expected */
		Local_u8ErrorStatus = RT_NOK;
	}
	return Local_u8ErrorStatus;
}

/*-----------------------------------------------------------------------------------*/
/*                                                                                   */
/*                            	  INTERRUPT HANDLERS		                     */
/*                                                                                   */
/*-----------------------------------------------------------------------------------*/

/************************************************/
/*   Timer/Counter1 Capture Event Interrupt	*/
/************************************************/
void __vector_6 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_6 (void)
{
	/* Check if Timer1 capture event function is registered or not */
	if(TIMER1_pvCaptureEventCallbackFunc != NULL)
	{
		/* Invoke Timer1 capture event function */
		TIMER1_pvCaptureEventCallbackFunc();
	}
}
/************************************************/
/*   Timer/Counter1 Compare Match A Interrupt	*/
/************************************************/
void __vector_7 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_7 (void)
{
	/* Check if Timer1 compare match for channel A function is registered or not */
	if(TIMER1_pvComapareMatchACallbackFunc != NULL)
	{
		/* Invoke Timer1 compare match for channel A function */
		TIMER1_pvComapareMatchACallbackFunc();
	}
}
/************************************************/
/*   Timer/Counter1 Compare Match B Interrupt	*/
/************************************************/
void __vector_8 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_8 (void)
{
	/* Check if Timer1 compare match for channel B function is registered or not */
	if(TIMER1_pvComapareMatchBCallbackFunc != NULL)
	{
		/* Invoke Timer1 compare match for channel B function */
		TIMER1_pvComapareMatchBCallbackFunc();
	}
}
/************************************************/
/* 	Timer/Counter1 Overflow Interrupt	*/
/************************************************/
void __vector_9 (void) __attribute__ ((signal,used, externally_visible)) ; \
void __vector_9 (void)
{
	/* Check if Timer1 overflow function is registered or not */
	if(TIMER1_pvOverflowCallbackFunc != NULL)
	{
		/* Invoke Timer1 overflow function */
		TIMER1_pvOverflowCallbackFunc();
	}
}
